# 组合数学大作业

内容：求解用模拟退火方法求解给定分布的随机TSP问题的最佳参数。

作者：俞阳

学号：17030188025



## 摘要

TSP问题，又称为旅行商问题，是组合优化中的一个NP困难问题，在运筹学和理论计算课学中非常重要。但以我的水平，没办法为大家攻克前沿阵地，只能在占领区打扫战场，练练手了。

> 对于一个二维平面S，其宽度为$x_0$,长度为$y_0$，其中随机分布着n个点$P_n$,求解从任意一点出发，经过所有点$P_n$所需的最短距离及方案。

对于这样一个NP难问题，没有通用的解法。因此我们通常使用启发式算法，比如模拟退火、蚁群算法或者遗传算法等。但对于启发式算法，求解一个相对较好的路径。通常有需要在求解前，需要提前指定的参数。那么对于一个特定的问题，究竟输入什么参数比较合适呢？我要做的就是探究在不同的平面形状和大小、不同的分布下，什么参数能以最小的计算资源获得最好的路径。

我会使用python来进行问题的生成和计算，使用的开发平台为可视化的jupyter notebook。

## 问题生成及优化前期望路径

首先，我需要一个能给定一个参数，就自动生成一个TSP问题的函数，完成后如下:

```python
import numpy as np
import networkx as nx
import random as rd
import matplotlib.pyplot as plt
import math
from functools import reduce

# 考虑到我们会有不同的问题，因此我们抽象了一个类，表示一个TSP问题。
class net():
    def __init__(self,points_num=10):
        self.points_num=points_num
    def edges(self):
        pass
    def length(self,way):
        return reduce(lambda x,y:x+y,[self.edges()[way[i]][way[i+1]] for i in range(self.points_num-1)])

# 这个函数，专门用于生成矩形的，随机均匀分布的TSP问题。
# x_range和y_range表示生成TSP问题的矩形的形状。
# points_num显而易见的，表示生成的点的数量。
class map_2d(net):
    def __init__(self, x_range=100, y_range=100, points_num=10):
        net.__init__(self,points_num)
        self.x_range=x_range
        self.y_range=y_range
        self.points = [[rd.uniform(0,x_range),rd.uniform(0,y_range)] for i in range(points_num)]
    def show(self):		# 此函数用于可视化某一个例子下，点的分布。
        plt.plot(self.points,'ro')
        plt.show()
    def edges(self):	# 此函数用于求解该问题中的邻接矩阵
        return np.array([[math.sqrt((pi[0]-qi[0])**2+(pi[1]-qi[1])**2) for pi in self.points] for qi in self.points])
      
if __name__ == '__main__':
  	tsp = [
        map_2d(
        		x_range=100,
          	y_range=100,
          	points_num=10
        ) for i in range(200)
    ]		# 生成200个实例，其长宽为100和100，中间有10个点。
```

随后，我们尝试着计算了一下，随机序列的路径长度。需要注意的是，由于每个问题都是随机生成的，因此每次都适用range(10)和生成一个随机序列，得到的路径期望是一样的。

​		对于平面上两点，我们认为其期望距离为
$$
|P_iP_{1+i}|=\int_0^{x_0}\int_0^{x_0}\int_0^{y_0}\int_0^{y_0} \sqrt{(x_1-x_0)^2+(y_1-y_0)^2} d{x_1}d_{x_2}d_{y_1}d_{y_2}
$$
​		对于10个点首尾相连的长度$|P_0P_1P_2P_3\cdots P_9|$,我们可以简单的认为
$$
\begin{align}
|P_0\cdots P_9| & =\sum_{i=0}^9|P_iP_{i+1}|\\ 
& = \sum_{i=0}^9 \int_0^{x_0}\int_0^{x_0}\int_0^{y_0}\int_0^{y_0} \sqrt{(x_1-x_0)^2+(y_1-y_0)^2} d{x_1}d_{x_2}d_{y_1}d_{y_2}\\
& = 10\times |P_iP_{i+1}|
\end{align}
$$

​		我尝试着建立了10000个STP问题并计算随机路径的长度，经观察其成显著的正态分布，代码和图像如下:

[img]

```python

```



## 最近算法

最近算法的核心思想，就是每当信使位于一个点上时，他的下一个目的地都修正为离他最近的未到达过的点。最近算法可以被认为是，人们在未经充分考虑的情况下，按直觉作出的决定。

其实现代码如下：



经过实验，我们认为由最近算法得出的路径长度，期望值为$1\backslash1$,在经过$100!$次运算的时候，权衡了利弊，达到了我们的要求

## 启发式算法

### 模拟退火算法

​		模拟退火算法是一种启发式算法，即，

> 一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。

​		但我认为，对于一个随机生成的问题，随着试验次数的增多，必定呈现一定程度的统计规律，最终也必将得到一个可以估计的测度。因此，我尝试着对如下问题做了1000次统计。

> 对于一个边长为$100\times 100$的正方形内，均匀分布着10个点，求从任意一点出发，

​		模拟退火的基本思想借鉴于金属缓慢冷却过程中形成较为牢固的结构的思想，即～～～其实现代码如下：

```python
	
```

​		其中可选项为:

1. 随机降温还是固定次数降温？

   ​		如果是随机降温，那么概率为多少？

   ​		如果是固定次数降温，那么该次数为多少？

2. 按数值下降还是按比例下降？

   ​		如果是按数值下降，那么每次下降的步长为多少？

   ​		如果按比例下降，那么每次降温，降到上一次的多少？

3. 随机选取交换的两个点，是否必须相邻？



​	为了显著的体现其分布特性，我对其中一种情况做了1000次计算作为验证，同时对其他各种情况做了少量次数的校验。经过模拟计算，我得到结论如下:

[img]

[       ]

​	考虑到